#### 实现vuex4基本结构和state
几个功能点：
+ 创建的 `store` 实例在全局共享
  + 创建 `store` 时用 `provide` 暴露 `store`；使用 `store` 时用 `inject` 注入 `store`
+ 创建 `store`：`createStore(options)`
  + 可以创建多个 `store`，所以可以采用工厂模式；
  + `state` 是响应式的，可以采用 `reactive` 实现响应式
+ 引入 `store`：`createApp().use(store,key)`
  + 这个语句相当于 `store.install(app,key)`，所以需要在 `store` 的构造函数中实现 `install(app, key)` 方法
+ 使用 `store`：`const store = useStore(key)`
  + 创建 `useStore` 方法，在该方法内部使用 `inject` 注入 `store`

具体实现：
```js
import { inject, reactive } from "vue";

/**
 * 创建容器，返回一个store
 * 1. 由于createStore可以多次使用，所以采用工厂模式（vuex4才具有多例模式，vue2中使用的vuex3只有单例）
 * 2. 多个store的具体使用方式：
 *    a. 引入store的时候设置标识：app.use(store, 'store1')；
 *    b. 使用store的时候传入该标识：const store = useStore('store1')
 * 3. options对象为创建store时传入的参数，包含state、getters、mutations、actions、modules、strict、plugins等
 */
const storeKey = "store"; // store 的默认key
class Store {
  constructor(options) {
    // vuex3 内部会创建一个vue实例来实现响应式，但是vuex4直接采用 vue3 提供的响应式方法
    const store = this;
    /**
     * 实现state的响应式
     * 【问】为何不直接使用 reactive(options.state)，要多包一层data属性？
     * 【答】因为在vuex中有一个重要的api replaceState（一般用来做状态持久化），它会直接重写整个state，导致无法触发响应式，如果包一层，则会对 store._state.data 进行修改，依然触发响应式。
     */
    // store._state.data
    store._state = reactive({ data: options.state });
  }
  get state() {
    return this._state.data;
  }
  // createApp().use(store,key) 相当于调用 store.install(app,key)，所以install方法接受两个参数：app 和 key
  install(app, injectKey) {
    // 全局暴露一个变量，暴露的是store实例
    app.provide(injectKey || storeKey, this); // this 指向 store 实例
    // 在vue2中为：Vue.prototype.$store = this
    app.config.globalProperties.$store = this; // 设置全局变量 $store
  }
}
export function createStore(options) {
  return new Store(options);
}

// 使用时在组件中引入
export function useStore(injectKey = storeKey) {
  return inject(injectKey);
}
```

#### 实现getters、mutations、actions
实现 `getters` ：遍历 `options.getters` 中的属性 `[key, fn]` ，设置 `store.getters[key] = fn(state)`，并使用 `computed` 对 `getters` 的值进行缓存；
实现 `mutation` 和 `actions`：遍历 `options.mutations` 和 `options.actions` 中的属性 `[key, mutation]` 和 `[key, action]`，设置 `store._mutations[key]` 和 `store._actions[key]` ，绑定 `this` 到 `store` 实例并传入其它相应参数；
实现 `commit` 和 `dispatch`：先将 `commit` 和 `dispatch` 设为箭头函数，使其内部 `this` 指向 `store` 实例；然后在内部分别调用 `store._mutations[type](payload)` 和 `store._actions[type](payload)`
具体实现如下：
```js
export function forEachValue(obj, fn) {
  Object.keys(obj).forEach((key) => fn(obj[key], key));
}
class Store {
  constructor(options) {
    const store = this;
    store._state = reactive({ data: options.state });

    /**
     * 实现getters
     */
    const _getters = options.getters; // {getter1: fn1, getter2: fn2}
    store.getters = {};
    forEachValue(_getters, function (fn, key) {
      Object.defineProperty(store.getters, key, {
        get: computed(() => fn(store.state)), // 用 computed 对 getters 进行缓存
      });
    });

    /**
     * 实现mutation和actions
     * 使用Object.create(null)创建空对象没有原型链，而使用 {} 创建空对象是由原型链的。
     *
     */
    store._mutations = Object.create(null);
    store._actions = Object.create(null);
    const _mutations = options.mutations;
    const _actions = options.actions;
    forEachValue(_mutations, (mutation, key) => {
      store._mutations[key] = (payload) => {
        mutation.call(store, store.state, payload);
      };
    });
    forEachValue(_actions, (action, key) => {
      store._actions[key] = (payload) => {
        action.call(store, store, payload);
      };
    });
  }
  // commit、dispatch必须写成箭头函数，来保证commit、dispatch里面的this指向store实例
  commit = (type, payload) => {
    this._mutations[type](payload);
  };
  dispatch = (type, payload) => {
    this._actions[type](payload);
  };
  get state() {
    return this._state.data;
  }

  install(app, injectKey) {
    app.provide(injectKey || storeKey, this);
    app.config.globalProperties.$store = this;
  }
}
```